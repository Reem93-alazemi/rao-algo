# -*- coding: utf-8 -*-
"""rao1-new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zq3I1YYLGRDVwIQ9WIYpKKUYXBmiGsrX
"""

# Python code of Rao-1 Algorithm # Unconstrained optimization
# Sphere function
import math
import random
import numpy as np

dv = int(input('Enter the number of design variables: '))
me = int(input('Enter the Maximum functions evaluation: '))
ps = int(input('Enter the Population size: '))

maxfes = me  # Maximum functions evaluation
dim = dv  # Number of design variables
SearchAgents_no = ps  # Population size
Max_iter = math.floor(maxfes / SearchAgents_no)  # Maximum number of iterations
lb = -5.12 * np.ones(dim)  # lower bound
ub = 5.12 * np.ones(dim)  # upper bound


def fitness(particle):
    y = 0
    for i in range(dim):
      if y > 5.12 or y < -5.12:
        y= y+ 10*i + 10*particle[i]**2 # the function   
      else: y =y+ 10*i + particle[i] ** 2 - 10 * math.cos(2 * math.pi * particle[i])

    return y


Positions = np.zeros((SearchAgents_no, dim))  # search agent position
best_pos = np.zeros(dim)  # search agent's best position
worst_pos = np.zeros(dim)  # search agent's worst position

finval = np.zeros(Max_iter)  # best score of each iteration
f1 = np.zeros(SearchAgents_no)  # function value of current population
f2 = np.zeros(SearchAgents_no)  # function value of updated population
for i in range(dim):
    Positions[:, i] = np.random.uniform(0, 1, SearchAgents_no) * (ub[i] - lb[i]) + lb[i]
for k in range(0, Max_iter):
    best_score = float("inf")
    worst_score = float("-inf")
    for i in range(0, SearchAgents_no):
        # Return back the search agents that go beyond the boundaries of the search space
        for j in range(dim):
            Positions[i, j] = np.clip(Positions[i, j], lb[j], ub[j])
        f1[i] = fitness(Positions[i, :])
        if f1[i] < best_score:
            best_score = f1[i].copy()  # Update best
            best_pos = Positions[i, :].copy()
        if f1[i] > worst_score:
            worst_score = f1[i].copy();  # Update worst
            worst_pos = Positions[i, :].copy()
    # Update the Position of search agents including omegas
    finval[k] = best_score
    print("The best solution is: ", best_score, " in iteration number: ", k + 1)
    Positioncopy = Positions.copy()
    for i in range(0, SearchAgents_no):
        for j in range(0, dim):
            r1 = random.random()  # r1 is a random number in [0,1]
            Positions[i, j] = Positions[i, j] + r1 * (best_pos[j] - worst_pos[j])  # change in position

            Positions[i, j] = np.clip(Positions[i, j], lb[j], ub[j])
        f2[i] = fitness(Positions[i, :])
    for i in range(0, SearchAgents_no):
        if f1[i] < f2[i]:
            Positions[i, :] = Positioncopy[i, :]
best_score = np.amin(finval)
print("The best solution is: ", best_score)